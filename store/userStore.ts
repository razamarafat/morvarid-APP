
import { create } from 'zustand';
import { createClient } from '@supabase/supabase-js';
import { supabase, supabaseUrl, supabaseAnonKey } from '../lib/supabase';
import { User, UserRole } from '../types';
import { useToastStore } from './toastStore';

const mapLegacyProductId = (id: string): string => {
    if (id === '1') return '11111111-1111-1111-1111-111111111111';
    if (id === '2') return '22222222-2222-2222-2222-222222222222';
    return id;
};

// Security: Generate a random string for initial passwords if not provided
const generateSecurePassword = (length = 12): string => {
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*";
    let retVal = "";
    if (window.crypto && window.crypto.getRandomValues) {
        const values = new Uint32Array(length);
        window.crypto.getRandomValues(values);
        for (let i = 0; i < length; i++) {
            retVal += charset[values[i] % charset.length];
        }
    } else {
        // Fallback for older browsers (less secure but functional)
        for (let i = 0, n = charset.length; i < length; ++i) {
            retVal += charset.charAt(Math.floor(Math.random() * n));
        }
    }
    return retVal;
};

interface UserState {
  users: User[];
  isLoading: boolean;
  fetchUsers: () => Promise<void>;
  addUser: (user: Omit<User, 'id'>) => Promise<{ success: boolean; error?: string; password?: string }>;
  updateUser: (user: User) => Promise<void>;
  deleteUser: (userId: string) => Promise<void>;
}

export const useUserStore = create<UserState>((set, get) => ({
  users: [],
  isLoading: false,

  fetchUsers: async () => {
      set({ isLoading: true });
      try {
          const { data: profiles, error: profilesError } = await supabase.from('profiles').select('*');
          if (profilesError) throw profilesError;

          const { data: userFarmsData, error: userFarmsError } = await supabase.from('user_farms').select('user_id, farm_id');
          if (userFarmsError) console.warn("Error fetching user_farms:", userFarmsError);

          if (profiles) {
              const { data: allFarms } = await supabase.from('farms').select('*');
              const mappedUsers = profiles.map((p: any) => {
                  const assignedFarmIds = userFarmsData 
                    ? userFarmsData.filter((uf: any) => uf.user_id === p.id).map((uf: any) => uf.farm_id) 
                    : [];
                  
                  const assignedFarms = allFarms 
                    ? allFarms.filter((f: any) => assignedFarmIds.includes(f.id)).map((f:any) => ({
                        ...f, 
                        productIds: (f.product_ids || []).map(mapLegacyProductId)
                      })) 
                    : [];

                  return {
                      id: p.id,
                      username: p.username,
                      fullName: p.full_name,
                      role: p.role as UserRole,
                      isActive: p.is_active,
                      phoneNumber: p.phone_number,
                      createdAt: p.created_at,
                      assignedFarms: assignedFarms
                  };
              });
              set({ users: mappedUsers, isLoading: false });
          } else {
              set({ isLoading: false });
          }
      } catch (error: any) {
           console.error('Fetch Users Failed:', error);
           set({ isLoading: false });
      }
  },

  addUser: async (userData) => {
      const rawUsername = userData.username || '';
      const sanitizedUsername = rawUsername.trim(); 
      
      if (!sanitizedUsername || sanitizedUsername.length < 3) {
          useToastStore.getState().addToast('نام کاربری باید شامل حداقل ۳ کاراکتر باشد', 'error');
          return { success: false, error: 'نام کاربری کوتاه است' };
      }
      
      const email = `${sanitizedUsername}@morvarid.com`; 
      
      // SECURITY FIX: Removed hardcoded password. 
      // If password provided by admin, use it. If not, generate a secure random one.
      const isAutoGenerated = !userData.password;
      const password = userData.password || generateSecurePassword();

      set({ isLoading: true });
      try {
          // Note: Using a temporary client for sign-up to avoid logging out the current admin
          const tempSupabase = createClient(supabaseUrl, supabaseAnonKey, {
              auth: {
                  persistSession: false,
                  autoRefreshToken: false,
                  detectSessionInUrl: false,
                  storage: { getItem: () => null, setItem: () => {}, removeItem: () => {} }
              }
          });

          // SEC-03 Warning: Role is sent from client here. 
          // Ideally should be handled by a Database Trigger or Edge Function.
          // For now, we rely on RLS policies to prevent non-admins from creating users.
          const { data, error } = await (tempSupabase.auth as any).signUp({
              email, 
              password,
              options: { data: { username: sanitizedUsername, full_name: userData.fullName, role: userData.role } }
          });

          if (error) {
              if (error.message.includes('unique')) {
                  useToastStore.getState().addToast(`این نام کاربری قبلاً در سیستم ثبت شده است.`, 'error');
                  return { success: false, error: 'نام کاربری تکراری است' };
              } else {
                  useToastStore.getState().addToast(`خطا در ساخت کاربر: ${error.message}`, 'error');
                  return { success: false, error: error.message };
              }
          }

          if (data.user) {
              // Note: The Trigger in DB usually handles profile creation, but we ensure it here for consistency if needed
              // or handle post-creation logic.
              
              if (userData.assignedFarms && userData.assignedFarms.length > 0) {
                  const inserts = userData.assignedFarms.map(f => ({ user_id: data.user!.id, farm_id: f.id }));
                  await supabase.from('user_farms').insert(inserts);
              }
              
              useToastStore.getState().addToast(`کاربر ${userData.fullName} با موفقیت ایجاد شد`, 'success');
              
              // Refresh user list
              await get().fetchUsers();

              // SEC-04: Return password to UI instead of console.log/alert
              return { success: true, password: isAutoGenerated ? password : undefined };
          }
          return { success: false, error: 'User data missing from response' };
      } catch (err: any) {
          console.error('User Add Exception:', err);
          useToastStore.getState().addToast(`خطای غیرمنتظره: ${err.message}`, 'error');
          return { success: false, error: err.message };
      } finally {
          set({ isLoading: false });
      }
  },

  updateUser: async (user) => {
      set({ isLoading: true });
      try {
          const { error: profileError } = await supabase.from('profiles').update({
              username: user.username, 
              full_name: user.fullName,
              role: user.role,
              is_active: user.isActive,
              phone_number: user.phoneNumber
          }).eq('id', user.id);

          if (profileError) throw profileError;

          const { error: deleteError } = await supabase.from('user_farms').delete().eq('user_id', user.id);
          if (!deleteError && user.assignedFarms && user.assignedFarms.length > 0) {
              const inserts = user.assignedFarms.map(f => ({ user_id: user.id, farm_id: f.id }));
              await supabase.from('user_farms').insert(inserts);
          }
          useToastStore.getState().addToast('ویرایش کاربر با موفقیت ثبت شد', 'success');
      } catch (error: any) {
          console.error('User Update Failed:', error);
          if (error.code === '23505') {
              useToastStore.getState().addToast('این نام کاربری قبلاً استفاده شده است.', 'error');
          } else {
              useToastStore.getState().addToast(`خطا در ویرایش کاربر: ${error.message}`, 'error');
          }
      } finally {
          await get().fetchUsers();
          set({ isLoading: false });
      }
  },

  deleteUser: async (userId) => {
      set({ isLoading: true });
      try {
          // SECURITY UPGRADE: Use Secure RPC instead of direct table update
          // This ensures that only authorized admins can perform this action via server-side logic
          const { error } = await supabase.rpc('soft_delete_user', {
              target_user_id: userId
          });

          if (error) {
              // Handle custom exceptions from RPC
              if (error.message.includes('Access Denied')) {
                  throw new Error('شما دسترسی لازم برای حذف کاربر را ندارید.');
              }
              if (error.message.includes('own account')) {
                  throw new Error('شما نمی‌توانید حساب کاربری خودتان را غیرفعال کنید.');
              }
              throw error;
          }

          useToastStore.getState().addToast('کاربر با موفقیت غیرفعال شد.', 'success');
      } catch (error: any) {
          console.error('User Delete Failed:', error);
          useToastStore.getState().addToast(`خطا در حذف کاربر: ${error.message || error.details || 'خطای ناشناخته'}`, 'error');
      } finally {
          await get().fetchUsers();
          set({ isLoading: false });
      }
  }
}));
