
import { create } from 'zustand';
import { supabase } from '../lib/supabase';
import { User, UserRole } from '../types';
import { useToastStore } from './toastStore';

const mapLegacyProductId = (id: string): string => {
    if (id === '1') return '11111111-1111-1111-1111-111111111111';
    if (id === '2') return '22222222-2222-2222-2222-222222222222';
    return id;
};

// Security: Generate a random string for initial passwords if not provided
const generateSecurePassword = (length = 12): string => {
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*";
    let retVal = "";
    if (window.crypto && window.crypto.getRandomValues) {
        const values = new Uint32Array(length);
        window.crypto.getRandomValues(values);
        for (let i = 0; i < length; i++) {
            retVal += charset[values[i] % charset.length];
        }
    } else {
        // Fallback for older browsers (less secure but functional)
        for (let i = 0, n = charset.length; i < length; ++i) {
            retVal += charset.charAt(Math.floor(Math.random() * n));
        }
    }
    return retVal;
};

interface UserState {
  users: User[];
  isLoading: boolean;
  fetchUsers: () => Promise<void>;
  addUser: (user: Omit<User, 'id'> & { password?: string }) => Promise<{ success: boolean; error?: string; password?: string }>;
  updateUser: (user: User) => Promise<void>;
  deleteUser: (userId: string) => Promise<void>;
}

export const useUserStore = create<UserState>((set, get) => ({
  users: [],
  isLoading: false,

  fetchUsers: async () => {
      set({ isLoading: true });
      try {
          const { data: profiles, error: profilesError } = await supabase.from('profiles').select('*');
          if (profilesError) throw profilesError;

          const { data: userFarmsData, error: userFarmsError } = await supabase.from('user_farms').select('user_id, farm_id');
          if (userFarmsError) console.warn("Error fetching user_farms:", userFarmsError);

          if (profiles) {
              const { data: allFarms } = await supabase.from('farms').select('*');
              const mappedUsers = profiles.map((p: any) => {
                  const assignedFarmIds = userFarmsData 
                    ? userFarmsData.filter((uf: any) => uf.user_id === p.id).map((uf: any) => uf.farm_id) 
                    : [];
                  
                  const assignedFarms = allFarms 
                    ? allFarms.filter((f: any) => assignedFarmIds.includes(f.id)).map((f:any) => ({
                        ...f, 
                        productIds: (f.product_ids || []).map(mapLegacyProductId)
                      })) 
                    : [];

                  return {
                      id: p.id,
                      username: p.username,
                      fullName: p.full_name,
                      role: p.role as UserRole,
                      isActive: p.is_active,
                      phoneNumber: p.phone_number,
                      createdAt: p.created_at,
                      assignedFarms: assignedFarms
                  };
              });
              set({ users: mappedUsers, isLoading: false });
          } else {
              set({ isLoading: false });
          }
      } catch (error: any) {
           console.error('Fetch Users Failed:', error);
           set({ isLoading: false });
      }
  },

  addUser: async (userData) => {
      const rawUsername = userData.username || '';
      const sanitizedUsername = rawUsername.trim(); 
      
      if (!sanitizedUsername || sanitizedUsername.length < 3) {
          useToastStore.getState().addToast('Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø¨Ø§ÛŒØ¯ Ø´Ø§Ù…Ù„ Ø­Ø¯Ø§Ù‚Ù„ Û³ Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¨Ø§Ø´Ø¯', 'error');
          return { success: false, error: 'Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ú©ÙˆØªØ§Ù‡ Ø§Ø³Øª' };
      }
      
      const email = `${sanitizedUsername}@morvarid.com`; 
      
      // ğŸš¨ SECURITY: PASSWORD HANDLING
      const isAutoGenerated = !userData.password;
      const password = userData.password || generateSecurePassword(16); 

      set({ isLoading: true });
      try {
          // ğŸš€ SECURITY UPGRADE: Use Database RPC 'create_new_user'
          // Instead of client-side signUp (which exposes role manipulation), we call a secure
          // Postgres function. This function checks if the caller is an ADMIN before creating the user.
          
          const { data: newUserId, error: rpcError } = await supabase.rpc('create_new_user', {
              email: email,
              password: password,
              user_metadata: { 
                  username: sanitizedUsername, 
                  full_name: userData.fullName, 
                  role: userData.role 
              }
          });

          if (rpcError) {
              console.error('RPC Create User Error:', rpcError);
              if (rpcError.message.includes('Access Denied')) {
                  useToastStore.getState().addToast('Ø´Ù…Ø§ Ø¯Ø³ØªØ±Ø³ÛŒ Ù„Ø§Ø²Ù… Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø®Øª Ú©Ø§Ø±Ø¨Ø± Ø±Ø§ Ù†Ø¯Ø§Ø±ÛŒØ¯.', 'error');
              } else if (rpcError.message.includes('unique')) {
                  useToastStore.getState().addToast('Ø§ÛŒÙ† Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ù‚Ø¨Ù„Ø§Ù‹ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ø«Ø¨Øª Ø´Ø¯Ù‡ Ø§Ø³Øª.', 'error');
              } else {
                  useToastStore.getState().addToast(`Ø®Ø·Ø§ Ø¯Ø± Ø³Ø§Ø®Øª Ú©Ø§Ø±Ø¨Ø±: ${rpcError.message}`, 'error');
              }
              return { success: false, error: rpcError.message };
          }

          if (newUserId) {
              // Handle farm assignments manually
              if (userData.assignedFarms && userData.assignedFarms.length > 0) {
                  const inserts = userData.assignedFarms.map(f => ({ user_id: newUserId, farm_id: f.id }));
                  await supabase.from('user_farms').insert(inserts);
              }
              
              useToastStore.getState().addToast(`Ú©Ø§Ø±Ø¨Ø± ${userData.fullName} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯`, 'success');
              
              // Refresh user list
              await get().fetchUsers();

              // Return password to UI for display
              return { success: true, password: isAutoGenerated ? password : undefined };
          }
          return { success: false, error: 'User ID missing from response' };

      } catch (err: any) {
          console.error('User Add Exception:', err);
          useToastStore.getState().addToast(`Ø®Ø·Ø§ÛŒ ØºÛŒØ±Ù…Ù†ØªØ¸Ø±Ù‡: ${err.message}`, 'error');
          return { success: false, error: err.message };
      } finally {
          set({ isLoading: false });
      }
  },

  updateUser: async (user) => {
      set({ isLoading: true });
      try {
          const { error: profileError } = await supabase.from('profiles').update({
              username: user.username, 
              full_name: user.fullName,
              role: user.role,
              is_active: user.isActive,
              phone_number: user.phoneNumber
          }).eq('id', user.id);

          if (profileError) throw profileError;

          const { error: deleteError } = await supabase.from('user_farms').delete().eq('user_id', user.id);
          if (!deleteError && user.assignedFarms && user.assignedFarms.length > 0) {
              const inserts = user.assignedFarms.map(f => ({ user_id: user.id, farm_id: f.id }));
              await supabase.from('user_farms').insert(inserts);
          }
          useToastStore.getState().addToast('ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø«Ø¨Øª Ø´Ø¯', 'success');
      } catch (error: any) {
          console.error('User Update Failed:', error);
          if (error.code === '23505') {
              useToastStore.getState().addToast('Ø§ÛŒÙ† Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª.', 'error');
          } else {
              useToastStore.getState().addToast(`Ø®Ø·Ø§ Ø¯Ø± ÙˆÛŒØ±Ø§ÛŒØ´ Ú©Ø§Ø±Ø¨Ø±: ${error.message}`, 'error');
          }
      } finally {
          await get().fetchUsers();
          set({ isLoading: false });
      }
  },

  deleteUser: async (userId) => {
      set({ isLoading: true });
      try {
          // SECURITY: Use Secure RPC instead of direct table update
          const { error } = await supabase.rpc('soft_delete_user', {
              target_user_id: userId
          });

          if (error) {
              if (error.message.includes('Access Denied')) {
                  throw new Error('Ø´Ù…Ø§ Ø¯Ø³ØªØ±Ø³ÛŒ Ù„Ø§Ø²Ù… Ø¨Ø±Ø§ÛŒ Ø­Ø°Ù Ú©Ø§Ø±Ø¨Ø± Ø±Ø§ Ù†Ø¯Ø§Ø±ÛŒØ¯.');
              }
              if (error.message.includes('own account')) {
                  throw new Error('Ø´Ù…Ø§ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø®ÙˆØ¯ØªØ§Ù† Ø±Ø§ ØºÛŒØ±ÙØ¹Ø§Ù„ Ú©Ù†ÛŒØ¯.');
              }
              throw error;
          }

          useToastStore.getState().addToast('Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯.', 'success');
      } catch (error: any) {
          console.error('User Delete Failed:', error);
          useToastStore.getState().addToast(`Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ú©Ø§Ø±Ø¨Ø±: ${error.message || error.details || 'Ø®Ø·Ø§ÛŒ Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡'}`, 'error');
      } finally {
          await get().fetchUsers();
          set({ isLoading: false });
      }
  }
}));
